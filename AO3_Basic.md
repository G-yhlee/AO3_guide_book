# AO3_Basic 내용 정리

## 1주차

### 1. 트레이너 설치 방법
   1. AO3 Trainer 파일 위치 : 공용 서버로 접속
    - \\fs-pub.gridone.net\fspub\10.Solution\02.Release\KOR\01.AutomateOne\03.AutomateOne 3.0\01.Trainer\Enterprise\x64
      맨 끝에 Update 붙는 파일은 버전 업데이트 파일이므로 설치X.
    - 가장 최신 버전의 설치 파일을 복사하여 공용서버가 아닌 로컬 폴더(본인의 노트북)에 옮겨 붙인 후, 설치를 진행한다. 

   2. Trainer를 이용하기 위해서는 계정을 등록해야함.
    - https://10.10.1.148:8011/automateone에 접속 후 아래의 계정으로 로그인
       ID : admin2 or (user1, user2, user3, user4) / PW : admin12#
       해당 페이지는 자주 이용하게 될 수 있으므로 즐겨찾기 해놓는 것을 권장. 
    - 왼쪽 탭에서 `사용자 관리` 항목으로 들어가면 우측 상단에 파란색 플러스 버튼을 클릭 (GIT 사용자 생성이 아님)
    - 본인이 사용할 아이디 및 비밀번호와 개인정보를 입력한 후 등록 완료.
![사용자 관리탭](images/1.png) 

   3. AO3를 실행시킨 후, 우측 상단 톱니바퀴(환경설정) 클릭
    - `서버 설정` 탭으로 이동하여 `매니저 서버` - `서버 주소` 탭에 아래의 주소를 입력 후 닫기
       https://10.10.1.148:8011/automateone

   4. AO3를 실행하여 2번에서 등록한 계정으로 로그인하면 완료.


### 3. 기본 구조 이해(v1)

#### 3_3. 스크립트 작성 개요 1

17:00에 스크립트를 서버로 올리기 전에 사전에 ibizbot Manager에서 설정이 필요합니다.
우선 아래의 링크로 접속합니다.

https://10.10.1.148:8011/automateone/

1. admin 계정으로 로그인 후, `프로젝트 관리`탭에서 프로젝트를 하나 생성해줍니다. (우측 상단의 파란색 플러스 버튼)
   - 적절한 프로젝트명을 입력하고 저장을 누릅니다. (EX. AO3_Basic)

2. 방금 생성한 프로젝트명을 클릭하면, 상단에는 프로젝트에 대한 정보와 하단에는 프로젝트 관리자가 표시됩니다. 
   - 하단의 `프로젝트 관리자`에서 본인의 계정을 찾아서 추가해줍니다.
   - 만약 본인의 계정을 프로젝트 관리자에 추가하지 않았다면, 로그인을 해도 더 이상 진행할 수 없습니다. 

3. admin 계정을 로그아웃하고, 본인의 계정으로 다시 접속합니다. 
   - 우측에 `프로세스` 탭에서 `스크립트`를 클릭합니다.
   - 우측 상단 플러스 버튼을 클릭하여 스크립트를 추가합니다.
   - 이때 스크립트 이름과 설명만 입력해도 정상적으로 저장이 가능합니다.

4. 다시 AO3 Trainer로 돌아와서 `스크립트 업로드`를 클릭하면, 2~3번에서 생성한 `프로젝트`와 `스크립트`가 보입니다.
   - 해당 스크립트를 선택하고, Note에 적당한 메모를 적어 확인을 클릭합니다.

5. ibizbot Manager에서 `프로세스 -> 스크립트`를 클릭하면 버전이 `1`로 바뀐 것을 확인할 수 있습니다.


### 5. 트레이너 기능 이해(초급)-변수(v1)

변수의 종류는 크게 전역변수, 지역변수로 구분된다.
- 자주색 글씨 : 전역변수
- 하늘색 글씨 : 지역변수(각 태스크에서 선언됨)

변수를 다루는 방법은 크게 4가지이다.
1.  변수 정의
    - AO2 버전에서 사용했던 `int, double, string, bool, object`과 
    - AO3 버전에서 추가된 `array, jobject, excel, database, image, dictionary, togglestate`로 지정 가능.
    - 단순 값 이외에도 여러 변수값을 연산자로 이용하여 계산된 값의 설정 가능.
    - C#으로 코딩하여 기능을 정의할 수도 있음.
    - `변수 이름 재처리`, `정의 재처리`, 전역변수 선언, 값 암호화도 가능하다.
2.  변수 삭제
    - 선언된 변수를 삭제하는 액션.
    - 변수 선언 시 지정한 변수 이름으로 삭제 가능
3.  리스트 변수 등록
    - 리스트로 값을 저장 가능.
    - 선언된 리스트 변수는 태스크 탭의 리스트 변수 탭에서 확인 가능   
4.  이미지 변수 저장
    - 액션 레코더의 image 모드로 설정 가능
    - 드래그를 통해 원하는 영역 지정 후 우클릭 - `이미지를 변수에 저장`
    - image 형식으로 변수에 저장되고, 변수의 이름을 지정할 수 있다.

### 7. 어플리케이션 사용하기(v1)

명령 실행의 속성 값에서 `명령 종료 대기 시간`은 기본으로 -1로 설정되어있다.
다음 프로세스로 진행하기 위해서는 0 또는 양수값(단위:ms)으로 설정해야 한다.

### 8. 디버깅 기초(v2)

`실행 여부`는 break point 역할을 하는데, 특정 지점까지 실행을 멈추는 기능을 수행한다. 원하는 액션을 우클릭하고 `중단점 설정`을 클릭하면 해당 기능을 사용할 수 있다.

스크립트 패키지에서 작업한 태스크를 태스크 탭으로 띄우기 위해서는, 스크립트 패키지 화면에 표시된 태스크 위에 마우스를 올리면 6개의 아이콘이 등장하는데, 왼쪽에서 3번째에 있는 `태스크 열기` 버튼을 클릭하면 된다.

태스크 탭에서 실행 여부 체크 박스를 해제하면 스크립트 패키지에서는 해당 액션에 빨간줄이 그어지는 것을 확인할 수 있다. 실행 여부를 해제하면, 해당 액션을 제외한 나머지 액션들이 실행된다.

### 9. 흐름제어(v1)

#### 06.반복문 탈출

이중 반복문 안에서 ` 반복문 탈출 `을 사용할 경우 최상단 반복문으로부터 벗어나고, 다음 액션을 실행한다.
 - `중단`은 `break`와 동일한 기능을 수행하는데, 최상단 반복문의 첫 실행 액션부터 다시 실행을 하게 된다.


### 11. 전체 혹은 일부

이미지 매칭과 같이 매칭하는 값이 전부(All) 같아야 하는 경우와 일부(Any)만 같아도 되는 경우로 나뉜다.

- All : 모든 매치가 성공하면 `MatchCount` 변수에 1이 반환되며, 그렇지 못하면 아무 값도 반환되지 않는다. 
  - `매치 인덱스 저장 변수`에는 아무 값도 반환되지 않는다.
- Any : 가장 먼저 매칭되는 액션의 인덱스 번호를 `매치 인덱스 저장 변수`에서 설정한 변수에 반환한다. 그렇지 못하면 아무 값도 반환되지 않는다.
  - 매치가 아닌 다른 액션이 정상적으로 실행되었다면, 해당 액션의 인덱스를 `매치 인덱스 저장 변수`에 반환한다.

### 13. List 내용 수행

12번의 Collection 내용 수행과 비슷한 개념으로, `List`에 들어있는 자료에 하나씩 접근하는 반복문을 수행한다.

#### Array와 List의 차이점?

결론부터 말하면, Array는 `index`로 접근이 가능하며, List는 그렇지 않다.

#### Array
  - `index`와 `값`의 쌍으로 이루어져 있다.
  - `index`는 값에 대한 유일한 식별자이다.
  - 논리적 저장 순서와 물리적 저장 순서가 일치하는데, 이 특성 덕분에 `index`로 해당 원소에 접근이 가능해진다.
  - 연속된 메모리의 공간으로 이루어져 있다.
  - 배열은 정의와 동시에 길이를 지정하며, 길이를 바꿀 수 없다.

##### 장점
  - 인덱스를 통한 검색이 용이하다.
  - 연속적이기 때문에 메모리 관리가 편하다.
##### 단점
  - 크기가 고정되어 있으므로 특정 원소가 삭제되면 삭제된 상태를 빈 공간으로 남겨야한다. -> 메모리 낭비로 이어짐
  - 정적이므로 배열의 크기를 컴파일 이전에 정해주어야 한다.
  - 컴파일 이후 배열의 크기를 변동할 수 없다.

#### List
  - 리스트는 순서가 있는 원소의 모임으로, 빈 원소는 절대 허용하지 않는다.
  - 리스트는 배열의 인덱스라는 장점 대신 __빈틈없는 데이터의 적재__ 라는 장점을 취했다.
  - 리스트에서 인덱스는 몇 번째 데이터인지만 나타내는 순서만 나타낸다. 
  - 순차성을 보장하지 못하기에 spacial locality 보장이 안되서 cash hit가 어렵다. (데이터 갯수가 확실히 정해져 있고, 자주 사용되면 array가 효율적이다.)
  - 불연속적으로 메모리 공간 차지
  - 포인터를 통한 접근
  
##### 장점
  - 포인터를 통해 다음 데이터의 위치를 가리키고 있어서 삽입과 삭제가 용이하다.
  - 동적이므로 크기가 정해져 있지 않다.
  - 메모리 재사용의 편리
  - 불연속적이므로 메모리 관리의 편리
##### 단점
  - 검색 성능이 좋지 않다.
  - 포인터를 통해 다음 데이터를 가르키므로 메모리 공간이 발생한다.

|     |추가/삭제|조회|데이터 크기|
|-----|-----|------|------|
|Array|느림|빠름|정적|
|List|빠름|느림|동적|

##### 참고자료 
 1. https://velog.io/@adam2/Array와-List그리고-Java-List

### 18. 데이터 테이블

#### `테이블에서 값 찾기`

Match(정확히 일치) 또는 Contains(포함) 옵션으로 테이블에서 값을 검색할 수 있다.
  - 값을 가져올 위치 : `[숫자 : 숫자]`형식으로 작성하며, 첫 번째 인자는 Row의 인덱스값, 두 번째 인자는 Column의 인덱스값을 의미한다. 
    - 검색어가 검색되면 Row와  Column에서 해당 위치의 값을 더한 위치의 값을 변수에 저장한다.
    ![테이블에서 값 찾기](images/데이터테이블_테이블에서_값_찾기.png)

    - [0:0]을 입력하면 찾은 값을 반환한다.
    ![테이블에서 값 찾기2](images/데이터테이블_테이블에서_값_찾기(2).png)

  - 검색할 컬럼 인덱스 : 검색할 행 영역을 지정한다. `값을 가져올 위치`와는 달리 인덱스 값이 0부터 시작하지 않고, 1부터 시작한다. 1 = 1열, 2 = 2열 ... 이렇게 검색을 한다. 전체 컬럼에서 검색하고 싶으면 값을 입력하지 않는다.

#### `Table 내 반복 수행`

반복 변수가 `object`타입으로 생성되어 지정한 열에 저장된 모든 데이터를 가져온다.

##### 예시

![테이블 반복수행](images/데이터테이블_반복수행.png)

- 메세지 박스에서 출력할 변수명은 `@rept_var:object@`이다. 
  - 1열에 있는 데이터를 출력하고 싶다면, 변수명 `rept_var`뒤에 `.0`을 붙인다. 
  - 2열에 있는 데이터를 출력하고 싶다면, 변수명 `rept_var`뒤에 `.1`을 붙인다. 
- 반복 변수는 `object`타입이기 때문에 문자열로 출력하고자 한다면 `ToString()`메소드를 사용해야 한다.
- 만약 테이블 전체를 출력하고자 한다면, 다음과 같이 1열과 2열이 반복해서 출력되도록 설정하면 된다.
  - ![테이블 반복수행2](images/데이터테이블_반복수행(2).png)

